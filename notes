To solidly express what you learned from the book, go to the beginning of each chapter, he has a great 
summary

you can solve many of the problems of multiple display resolutions by using an elastic layout
based on relative units, instead of absolute values


some relative units are %'s and ems

  percentages: setting the width property of an element to 25% makes the element use 25% of its parents
  width


  em: one em is equal to the height of the font


ems are ridiculously useful:
  you can set a main font size that all content inherits from, which standardizes ems across the app



  this means that you have to choose a font-size that makes sense
  normally you choose a size that divides up the display into a nice grid


  jewel warrior uses a 8x8 board and the game width is set to 320px, if the game takes up 
  all of the width, a font-size value of 40 pixels whould mean that each cell on the board is
  a 1x1 em block



to really udnerstant the way that mobile devices display web content, you need 
to understand what the viewport is and how it relates to the page

you can think of the viewport as the area on which the browser renders the page

the dimenstions of the viewport and the dimensions of the hole through which
the page is viewed are not the same thing


in desktop browsers, the width of the viewport is generally equal to the width of browser window

the viewport of a site can be controlled with a meta tag

  <meta name="viewport" content="...">


to make your views scalable, you usually want to use special device-width and device-height values 
in the viewport tag, 

  this way, the device can automatically scale the content to fill the screen



its a good idea to disable user scaling in the game, this wil lstop them from accidentally zooming in




no matter how hard you try, sometimes you just cant make a single set of css rules behave properly across
all devices and resolutions

sometimes, the best solution is to make seperate stylesheets for different display sizes and load
the appropriate ones when needed, 

you can make media queries to decide which stylesheet you want
media queries basically set conditions based on features of the media

eg media query

<link rel="stylesheet" media="print and resolution > 150dpi" href="print150.css">

the above applies a special sheet if the device has the required pixel density


@media screen and (min-width : 480px) {
  body {
  font-size: 150%;
  }
} 


^if the content is displayed on a screen and if the width of the display is at least 480px, 
 the font-size of the body is 150%


 detecting device orientation is relatively easy: 

 @media screen and (orientation: portrait) {
  #sidebar {
    display: none;
  }
 }

 @media screen and (orientation: landscape) {
   #sidebar {
    display: block;
   }
 }

 ^only show the sidebar element when the page is displayed in landscape mode



 its tough dealing with 2 different orientations, you cant cram 
 a tall menu into a limited vertical space, it will lead to small buttons

 a better solution is to have them automatically adjust themselves in a 2x2 grid if the space permits



 when you run a web application in safari, the available screen space is reduced to the surrounding ui


 for iphones: 

  the ipod touch has a resolution of 320x480, but because of the safari ui, you can only really use
  320x360 for the application


  by adding a meta tag to index.html you can make safari recognize it as a web app and should
  not be treated as a simple link


  <meta name="apple-mobile-web-app-capable" content="yes">

  ^ios knows that when this page is bookmarked and launched form the home screen it must do so in full
  screen mode without the usual safari interface

  detecting standalone apps

  safari provides an easy way to determine if the page is being viewed as a web app or a regular
  web page



  after you know how to detect the standalone web app, you can use that to modify the application accordingly, there is no built in way to do the detection in css,


  Modernizr adds css classes to the html element id to indicate which features are supported





  by default ios uses a tiny screenshot of the app when it generates an icon, naturally that wont 
  always produce great results

  with a special link you can specify an icon file to use instead of the screenshot

  <link rel="apple-touch-icon" href="icon.png">

  normally the os does some extra stuff to the image, to tell it to not be a faggot, use this instead:

  <link rel="apple-touch-icon-precompoed" href="images/ios-icon.png">


  because idevices have different resolutions, ios also supports application icons of varying sizes

  if you create icons in different sizes, you can point to them in the html by adding a sizes parameter to the link element for each resolution you want to support


  when the user launches the game in standalone mode and later exits the game, 

  ios saves a picture of it, the next time the app is launched this image is displayed until the page
  is loaded

  all of the ios devices need an image that takes up the full screen minus the top 20 pixels that
  are reserved for the native status bar

  320X460 for the iphone and ipad

  768x1004 for the ipad



  on the ipad you can add an extra startup image for landscape mode, which would be 748x1004

  specifying a startup image

  <link rel="apple-touch-startup-image" href="images/ios-startup-748x1024.png" media="screen and (min-device-width: 768px) and (orientation: landscape)">

  if you add multiple link elements the last element simply overrides all the others unless you specify a media query to target the specific devices




all mobile devices use a standard 20px status bar at the top of the screen, even when the webapp is
running in full screen mode its visible

by adding a meta tag to the page, you can choose between a few different styles for the status bar

<meta name="apple-mobile-web-app-status-bar-style" content="black">
^toggles a solid black background on the status bar




ideally, a game running in a wep app should be no different from native form 


you want to disable overscroll

you can do this by disabling touch scroll altogether



the android browser doesnt have a feature like the meta tag that hides the safari ui

when a page loads in the android browser, it is usually displayed in such a way that the url bar
is still visible

with JS you can make the address bar disappear, or at last move it out of the way

the trick is to force the browser to scroll to the top of the page

if theres enough content, it automatically pushes the address bar out of view
because the height is set to 100%, the game only takes up as much space as it can, so scrolling to the top has no effect

you can make sure the page is long enough by increasing the height of the html element

mobile browsers have a few behaviors that are best left disabled for games


when you keep your finger pressed down for a second or two on an image a small callout appears giving you the option to follow the link, save the image, etc

the user should be able to tap and press anything without interference 

this disables the callout 

-webkit-touch-callout: none;



-webkit-user-select: none;
^disables the ability to select text and images 

the android browser also highlights clickable elements when you tap them, which you can remove with

-webkit-tap-highlight-color: rgba(0,0,0,0)

under some circumstances, the browser automatically adjusts the size of the text to account for the change in available size

you can disable automatic readjustment with

-webkit-text-size-adjust: none;





ADDING SHIT TO THE GAME BOARD
  necessary game logic
  encapsulating the state of the board in an isolated module that allows modifications to the board only when all the game rules are followed
  ensuring that the board automatically reacts to the swaps and rearranges the remaining jewels


  there are some issues that arise when the game must be able to use two different sources that control the board

  the single player experience relies on the local client side game logic

  but the game must also work with a server side implementation of the same rules


  the games mechanics are seperated from the display and input elements of the game

  the board module is a data model for the games state(gem positions)

  the only real function that it exposes is a query function for accessing the jewels on the board
  and a function for swapping jewels

  the swapping function attemts to sswap only a pair of jewels because jewels are swappable only if certain conditions are met

  swapping also has consequences, jewels are removed, new ones fall

  the board module handles all these things automatically

  at some point, you can add webworkers to move the board logic to a seperate thread by creating
  a web worker based bard module that exposes the same methods as the one created in this chapter

  web workers communicate with the rest of the application via an asynchronous messaging api, which means that all the board modules must be able to function asynchronously 

  if you wanted to have a module that validates board data with a server side backend, you need to send
  an asynchronous ajax request to the server

  every function that modifies the game state would require a trip to the server and back before the response could be given to the caller

  in other words just because the function call returns, doesnt mean the result is ready


  you can solve this problem of deferred response in several ways

    one of the ways is using full-fledged custom event dispatching, or the concept of promise objects (node.js shit)

    the simplest solution is to just provide a callback function as an argument to the relevant method, and have that method call the callback function when it is done

  when you fill the board you have to be careful to fill the board in such a way that there are no
  combinations when the board is initially created, that would result in the player getting points 
  without doing anything


after performing a swap, the game must search for chains to remove


because the swap function needs to be exposed to the rest of the board, and because it potentially modifies the board, it mush work in the same asynchronous fashion as the initialize function

besides the two sets of coords, swap takes a callback function as its 5th argument

if the swap succeeds, the callback function is called with either a list of events that happened, or false (if its invalid)


DELEGATING TASKS TO WEB WORKERS
  how to use web workers to create a worker based version of the board module 

javascript is single threaded by design, you cannot run things in parallel, anything you ask the
browser to is processed in a serial manner. when you use functions like setTimeout or setInterval what youre really doing is pushing those functions onto the same event loop that the main thread uses

one drawback to this is that you cannot have any function that blocks the execution and expect the browser to behave

xmlhhttprequest obejct has synch and non sycnh modes, if you use synch requests, you tie up the thread,
blocking any further execution until the request has finished

web workers solve this problem by introducing functionality that resembles threads

with web workers, you can load scripts and make them run in the background, independent from the main thread. a script that runs in a worker cannot affect or lock up the main thread (the browser window, which means you can do
massive cpy intensive processing

the web workers specification defines the functionality of workers as being
thread-like because implementations dont necessariyl have to use actual OS-level threads

theyre thread-like, not actual threads per say, since:
  -the implementation of workers is up to browser vendors
even though they are often mentioned in the same sentence as other html5 features, web workers
are not part of the html5 specification but have their own specification.

workers do have some limitations- 
  in most cases these contraints dont pose problems as long as your code is encapsulated well and data
  is isolated...


1. the first isse is the seperation of state and data 
    no data from the parent thread is accessible from the worker thread, or vice versa. 
    any changes to the data of either thread must happen through the messaging API
      this limitation actually helps a lot with avoiding nasty concurrency problems.
    if workers could freely manipulate the variables in the parent thread, the risk of running into
    problems such as deadlocks, and race conditions would make workers very tough

2. no dom access
    this seperation btween worker and parent thread also means that workers have no access to the DOM 
    (window and document objects dont exist in them)
    workers can however send messages to the main thread that are then used to change the dom
    the messaging api doesnt restrict you from defining your own message protocol for updating certain
    dom elements or exchanging information about the elements of the document.

      if youre going to do alot of dom manipulation, its better to reconsider if that functionality should belong to a worker

web workers are not supported in all browsers (IE is missing them, shocking)

theyre also not supported on mobile browsers

since this is the case, the best thing to do is make your use of workers optional


what can workers do?
  in general workers can do anything you would otherwise do with javascript

  creating a worker simply loads a script and executes it in a background thread

  in pure js you have access to a few extra methods

  importScripts()
    - you provide this function a list of paths that point to scripts you want to load
    - the function is variadic, which means that you must specify the paths as individual arguments

  importScripts('script1.js', 'script2.js', ....)


  all these files are loaded synchronously, so the function doesnt return until all scripts loaded

  after a script is loaded, it is executed within the same scope as the calling worker

  this means that the script can use any variables and functions declared in the worker and the worker can subsequently use any variables and functions introduced by the imported script (allows for easy seperation of worker code into discrete modules)

  the script that created the worker can terminate the worker when it is no longer needed, but the worker itself can also choose to exit

  ( a worker can kill itself by calling the close() function)


  the timer functions that you know from the window object are all available in worker threads, which means that you are free to use the following functions

    setTimeout()
    clearTimeout()
    setInterval()
    clearInterval()


you can also use the xmlhttprequest object to create and process background ajax requests

  this object is especially useful if you need a background worker that continuously pings the server for updates that are then relayed to the main thread via the api

  because blocking in a worker thread does not affect the main ui thread, you can even do synchronous requests, which is normally a bad idea in non-worker code (it freezes the browser)


  Websockets support in worker threads is a bit of a gray area.
    eg. chrome allows it, but firefox only lets you use it in the main JS thread



to create workers you use the worker constructor

  var worker = new Worker('myworker.js')


you can only create workers from scripts that have the same origin as the creating script
  that means you cant refer to the scripts on other domains 
  the script must also be loaded using the same scheme
    - (the script cant use https if the page uses http)

you also cant create workers from a script running locally

when youre done using the worker you can call:

 worker.terminate()

this kills it an frees up memory


you can create more than worker thread
you can also create more than one worker from the same script
  some tasks are well suited for this kind of parallelization, and can provide a performance boost
  unfortunately workers are not meant to be created in large numbers due to the overhead cost
  of setting them up, so keep it down to 1 or two workers



SENDING MESSAGES -
  workers and their parent communicate through a common messaging API
  data is sent back and forth through strings, but that doesnt mean you can send only one string messages


  if you send any complex structure such as an array or object, it is automatically converted to json

  this automatic conversion of json allows you to build fairly advanced messages, but not that some things (like dom elements) cant be converted to json


  in the creating thread, call the postMessage() method on the worker with the data that you want to send

  //send a string
  worker.postMessage('hello worker')
  //send an array
  worker.postMessage([0,1,2])
  send an object literal
  worker.postMessage({
    command: 'pollServer',
    timeout: 1000
  })

  in the same way, simply call postMessage() to send messages from the worker to the main thread

  postMessage('im read to work master')




RECEIVING MESSAGES

  messages can be intercepted by listening for the message event.
  in the parent thread, the event is fired on the worker object, whereas on the worker object, it is fired on the global object


  to listen for messages from a worker, attach a handler to the message event

  worker.addEventListener('message', function(event) {
    //message received from the worker thread
  }, false)


  in the worker thread you listen for message events on the global object
  addEventListener('message', function(event) {
    //message received from the main thread
  })

  in both cases, you can message data in the data property on the event object.
  its automatically encoded from json


CATCHING ERRORS
  if an error occurs in a worker thread, you might want to know about it in the main thread so that
  you can display a message, create a log entry, and so forth.

  in addition to the message event, worker objects also emit an error event, which is fired
  if an error happens that is not caught in the worker thread

  when the event fires, it is too late to do anything about the error. the worker has already stopped whatever it was doin, but at least you can be informed that the error occured

  worker.addEventListener('error', function(error) {
    alert('worker error: ' + error)
  }, false)


SHARED WORKERS
  there are two types of web workers: dedicated, and shared.

  shared workers can have multiple connections, they are not bound to one html page. 
  if you have multiple html pages from the same origin running in the same browser, these pages can 
  all access any shared workers created by one of the pages


  to create a shared worker, use the SharedWorker() constructor.
  in addition to the script path, this constructor also takes a second optional name parameter.
  if the name parameter is not given, an empty string is used for the name.
  if you attempt to create a shared worker and one has already been created with the same script and name, a new connection to that worker is created instead of a brand new worker

  shared workers dont have a global message event like dedicated workers do.
  instead they must listen for connect events that fire whenever a new page creates a connection to 
  the worker

  communication between the worker and connecting threads happens via port objects that emit message events and expose the postMessage() method

  the port.start() function must also be called before messages can be received



  look at this example:
    it will use a dedicated worker to do some intensive processing, and freeing up the main thread


    function isPrime(n){
      if (n < 2) return false;
      for (var i = 2, m=Math.sqrt(n); i <= m; i++)
        if (n % i === 0) {
          return false
        }
    }
    return true
    }


  if a pair of divisors exists, one of the divisors must be smaller than or equal to the square root
  of n, so you need to test only numbers in the range [2, sqrt(n)] to determine the primality of n

  so for each number i from 2 to sqrt(n), you use the remainder operator to test whether i can divide n
  if it can n is not prime and isPrime returns false

  if the loop exits without finding a divisor, n is prime and returns true


WHEN TO USE WEB WORKERS IN GAMES
  do you need to move the game element to a seperate worker thread?
  does the game element do anything that could run independently

  does the game element depend on having access to the dom?

  remember that worker threads cannot access the document, so anything to do with the dom must be in the main thread


  good candidates are artificial intelligence, and physics simulations

    theyre demanding on the cpu and dont need to run in the same thread as long as the data is kept synchronized

THE WORKER MODULE
  because the game module was designed with multiplayer support in mind it already has an asynchronous interface.




importing the script the regular board module allows you to reuse  funcitonality
 because the module is created in the jewel namespace, an empty jewel obect is created prior to importing the script if the object doesnt exist when the script is imported, youd get an error

when the worker receives a message from the game, it needs to call the
 appropriate method on the imported board module and post back the results
 the messages coming from the game to the worker use a custom message format described
 by this object literal:
 
 {
  id: number,
  command: string
  data: any
 }

 id identifies the mesage, the command property
 is a string that determines what the worker should do
 data is all the data the worker needs to do the command

 all messages posted to the worker trigger a response message with this format:

 {
  id: number,
  data: any,
  jewels: array
 }


 the id is the id number from the original message, 
 data is the response data, and jewels 
 contains a 2d array that represents the current state of the jewel board
 the board data is always attached so that the main thread can keep a local copy of the data for
 easy access

the worker has 2 commands, initialize and swap
theyre mapped to the corresponding methods on the board module

when the worker receives the initialize command, data must contain the settigs object from the jewel
namespace in the parent


the board initialize function takes a callback function as its first and only argument, a special
callback function is defined in the worker and is passed to board.initialize and any other asynch
board methods

when the callback is called function is called, the data parameter is sent to the main thread as a message, and its then up the main thread to handle the callback message




the worker defined the callback method, whenever anything happens that
changes the state of the board (initialize, and swap), the worker 
sends a message to the main thread 

the game should be able to run with and without worker support

  you need a new worker-based board module that has the same interface as the non-worker
  board.js module

any functions exposed in the board module must also exist in the worker board module with the same signiatures  (initialize(), swap(), getBoard() )


if they have the same signatures, you can replace one module with the other, and 
the game doesnt care

you know that only some browsers support workers, the board board module (for the workers)

must be loaded only if workers are available

if not, the game must fall back to the regular board module


when you use the worker constructor to create a new worker, the script is automatically pulled from the server

it would be nice if the file were already in the cache so the user didnt have to wait for the additional http request before the game could begin

if you simply added the script to the modernizr load call in the loader script, errors could occur because the worker script uses functions that are not available outside the worker (like importScripts() )


you could test for the presence of that function and execute the rest of code only if it exists

a more elegant method would be to just make sure the file is loaded and not executed

yepnope uses something called prefixes - 
  they enable you to define a prefix that if found in the script path, triggers extra functionality


CREATING GRAPHICS WITH CANVAS





















































