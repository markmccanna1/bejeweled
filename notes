you can solve many of the problems of multiple display resolutions by using an elastic layout
based on relative units, instead of absolute values


some relative units are %'s and ems

  percentages: setting the width property of an element to 25% makes the element use 25% of its parents
  width


  em: one em is equal to the height of the font


ems are ridiculously useful:
  you can set a main font size that all content inherits from, which standardizes ems across the app



  this means that you have to choose a font-size that makes sense
  normally you choose a size that divides up the display into a nice grid


  jewel warrior uses a 8x8 board and the game width is set to 320px, if the game takes up 
  all of the width, a font-size value of 40 pixels whould mean that each cell on the board is
  a 1x1 em block



to really udnerstant the way that mobile devices display web content, you need 
to understand what the viewport is and how it relates to the page

you can think of the viewport as the area on which the browser renders the page

the dimenstions of the viewport and the dimensions of the hole through which
the page is viewed are not the same thing


in desktop browsers, the width of the viewport is generally equal to the width of browser window

the viewport of a site can be controlled with a meta tag

  <meta name="viewport" content="...">


to make your views scalable, you usually want to use special device-width and device-height values 
in the viewport tag, 

  this way, the device can automatically scale the content to fill the screen



its a good idea to disable user scaling in the game, this wil lstop them from accidentally zooming in




no matter how hard you try, sometimes you just cant make a single set of css rules behave properly across
all devices and resolutions

sometimes, the best solution is to make seperate stylesheets for different display sizes and load
the appropriate ones when needed, 

you can make media queries to decide which stylesheet you want
media queries basically set conditions based on features of the media

eg media query

<link rel="stylesheet" media="print and resolution > 150dpi" href="print150.css">

the above applies a special sheet if the device has the required pixel density


@media screen and (min-width : 480px) {
  body {
  font-size: 150%;
  }
} 


^if the content is displayed on a screen and if the width of the display is at least 480px, 
 the font-size of the body is 150%


 detecting device orientation is relatively easy: 

 @media screen and (orientation: portrait) {
  #sidebar {
    display: none;
  }
 }

 @media screen and (orientation: landscape) {
   #sidebar {
    display: block;
   }
 }

 ^only show the sidebar element when the page is displayed in landscape mode



 its tough dealing with 2 different orientations, you cant cram 
 a tall menu into a limited vertical space, it will lead to small buttons

 a better solution is to have them automatically adjust themselves in a 2x2 grid if the space permits



 when you run a web application in safari, the available screen space is reduced to the surrounding ui


 for iphones: 

  the ipod touch has a resolution of 320x480, but because of the safari ui, you can only really use
  320x360 for the application


  by adding a meta tag to index.html you can make safari recognize it as a web app and should
  not be treated as a simple link


  <meta name="apple-mobile-web-app-capable" content="yes">

  ^ios knows that when this page is bookmarked and launched form the home screen it must do so in full
  screen mode without the usual safari interface

  detecting standalone apps

  safari provides an easy way to determine if the page is being viewed as a web app or a regular
  web page



  after you know how to detect the standalone web app, you can use that to modify the application accordingly, there is no built in way to do the detection in css,


  Modernizr adds css classes to the html element id to indicate which features are supported





  by default ios uses a tiny screenshot of the app when it generates an icon, naturally that wont 
  always produce great results

  with a special link you can specify an icon file to use instead of the screenshot

  <link rel="apple-touch-icon" href="icon.png">

  normally the os does some extra stuff to the image, to tell it to not be a faggot, use this instead:

  <link rel="apple-touch-icon-precompoed" href="images/ios-icon.png">


  because idevices have different resolutions, ios also supports application icons of varying sizes

  if you create icons in different sizes, you can point to them in the html by adding a sizes parameter to the link element for each resolution you want to support


  when the user launches the game in standalone mode and later exits the game, 

  ios saves a picture of it, the next time the app is launched this image is displayed until the page
  is loaded

  all of the ios devices need an image that takes up the full screen minus the top 20 pixels that
  are reserved for the native status bar

  320X460 for the iphone and ipad

  768x1004 for the ipad



  on the ipad you can add an extra startup image for landscape mode, which would be 748x1004

  specifying a startup image

  <link rel="apple-touch-startup-image" href="images/ios-startup-748x1024.png" media="screen and (min-device-width: 768px) and (orientation: landscape)">

  if you add multiple link elements the last element simply overrides all the others unless you specify a media query to target the specific devices




all mobile devices use a standard 20px status bar at the top of the screen, even when the webapp is
running in full screen mode its visible

by adding a meta tag to the page, you can choose between a few different styles for the status bar

<meta name="apple-mobile-web-app-status-bar-style" content="black">
^toggles a solid black background on the status bar




ideally, a game running in a wep app should be no different from native form 


you want to disable overscroll

you can do this by disabling touch scroll altogether



the android browser doesnt have a feature like the meta tag that hides the safari ui

when a page loads in the android browser, it is usually displayed in such a way that the url bar
is still visible

with JS you can make the address bar disappear, or at last move it out of the way

the trick is to force the browser to scroll to the top of the page

if theres enough content, it automatically pushes the address bar out of view
because the height is set to 100%, the game only takes up as much space as it can, so scrolling to the top has no effect

you can make sure the page is long enough by increasing the height of the html element

mobile browsers have a few behaviors that are best left disabled for games


when you keep your finger pressed down for a second or two on an image a small callout appears giving you the option to follow the link, save the image, etc

the user should be able to tap and press anything without interference 

this disables the callout 

-webkit-touch-callout: none;



-webkit-user-select: none;
^disables the ability to select text and images 

the android browser also highlights clickable elements when you tap them, which you can remove with

-webkit-tap-highlight-color: rgba(0,0,0,0)

under some circumstances, the browser automatically adjusts the size of the text to account for the change in available size

you can disable automatic readjustment with

-webkit-text-size-adjust: none;





ADDING SHIT TO THE GAME BOARD
  necessary game logic
  encapsulating the state of the board in an isolated module that allows modifications to the board only when all the game rules are followed
  ensuring that the board automatically reacts to the swaps and rearranges the remaining jewels


  there are some issues that arise when the game must be able to use two different sources that control the board

  the single player experience relies on the local client side game logic

  but the game must also work with a server side implementation of the same rules


  the games mechanics are seperated from the display and input elements of the game

  the board module is a data model for the games state(gem positions)

  the only real function that it exposes is a query function for accessing the jewels on the board
  and a function for swapping jewels

  the swapping function attemts to sswap only a pair of jewels because jewels are swappable only if certain conditions are met

  swapping also has consequences, jewels are removed, new ones fall

  the board module handles all these things automatically

  at some point, you can add webworkers to move the board logic to a seperate thread by creating
  a web worker based bard module that exposes the same methods as the one created in this chapter

  web workers communicate with the rest of the application via an asynchronous messaging api, which means that all the board modules must be able to function asynchronously 

  if you wanted to have a module that validates board data with a server side backend, you need to send
  an asynchronous ajax request to the server

  every function that modifies the game state would require a trip to the server and back before the response could be given to the caller

  in other words just because the function call returns, doesnt mean the result is ready


  you can solve this problem of deferred response in several ways

    one of the ways is using full-fledged custom event dispatching, or the concept of promise objects (node.js shit)

    the simplest solution is to just provide a callback function as an argument to the relevant method, and have that method call the callback function when it is done

  when you fill the board you have to be careful to fill the board in such a way that there are no
  combinations when the board is initially created, that would result in the player getting points 
  without doing anything


after performing a swap, the game must search for chains to remove


because the swap function needs to be exposed to the rest of the board, and because it potentially modifies the board, it mush work in the same asynchronous fashion as the initialize function

besides the two sets of coords, swap takes a callback function as its 5th argument

if the swap succeeds, the callback function is called with either a list of events that happened, or false (if its invalid)





















































