To solidly express what you learned from the book, go to the beginning of each chapter, he has a great 
summary

you can solve many of the problems of multiple display resolutions by using an elastic layout
based on relative units, instead of absolute values


some relative units are %'s and ems

  percentages: setting the width property of an element to 25% makes the element use 25% of its parents
  width


  em: one em is equal to the height of the font


ems are ridiculously useful:
  you can set a main font size that all content inherits from, which standardizes ems across the app



  this means that you have to choose a font-size that makes sense
  normally you choose a size that divides up the display into a nice grid


  jewel warrior uses a 8x8 board and the game width is set to 320px, if the game takes up 
  all of the width, a font-size value of 40 pixels whould mean that each cell on the board is
  a 1x1 em block



to really udnerstant the way that mobile devices display web content, you need 
to understand what the viewport is and how it relates to the page

you can think of the viewport as the area on which the browser renders the page

the dimenstions of the viewport and the dimensions of the hole through which
the page is viewed are not the same thing


in desktop browsers, the width of the viewport is generally equal to the width of browser window

the viewport of a site can be controlled with a meta tag

  <meta name="viewport" content="...">


to make your views scalable, you usually want to use special device-width and device-height values 
in the viewport tag, 

  this way, the device can automatically scale the content to fill the screen



its a good idea to disable user scaling in the game, this wil lstop them from accidentally zooming in




no matter how hard you try, sometimes you just cant make a single set of css rules behave properly across
all devices and resolutions

sometimes, the best solution is to make seperate stylesheets for different display sizes and load
the appropriate ones when needed, 

you can make media queries to decide which stylesheet you want
media queries basically set conditions based on features of the media

eg media query

<link rel="stylesheet" media="print and resolution > 150dpi" href="print150.css">

the above applies a special sheet if the device has the required pixel density


@media screen and (min-width : 480px) {
  body {
  font-size: 150%;
  }
} 


^if the content is displayed on a screen and if the width of the display is at least 480px, 
 the font-size of the body is 150%


 detecting device orientation is relatively easy: 

 @media screen and (orientation: portrait) {
  #sidebar {
    display: none;
  }
 }

 @media screen and (orientation: landscape) {
   #sidebar {
    display: block;
   }
 }

 ^only show the sidebar element when the page is displayed in landscape mode



 its tough dealing with 2 different orientations, you cant cram 
 a tall menu into a limited vertical space, it will lead to small buttons

 a better solution is to have them automatically adjust themselves in a 2x2 grid if the space permits



 when you run a web application in safari, the available screen space is reduced to the surrounding ui


 for iphones: 

  the ipod touch has a resolution of 320x480, but because of the safari ui, you can only really use
  320x360 for the application


  by adding a meta tag to index.html you can make safari recognize it as a web app and should
  not be treated as a simple link


  <meta name="apple-mobile-web-app-capable" content="yes">

  ^ios knows that when this page is bookmarked and launched form the home screen it must do so in full
  screen mode without the usual safari interface

  detecting standalone apps

  safari provides an easy way to determine if the page is being viewed as a web app or a regular
  web page



  after you know how to detect the standalone web app, you can use that to modify the application accordingly, there is no built in way to do the detection in css,


  Modernizr adds css classes to the html element id to indicate which features are supported





  by default ios uses a tiny screenshot of the app when it generates an icon, naturally that wont 
  always produce great results

  with a special link you can specify an icon file to use instead of the screenshot

  <link rel="apple-touch-icon" href="icon.png">

  normally the os does some extra stuff to the image, to tell it to not be a faggot, use this instead:

  <link rel="apple-touch-icon-precompoed" href="images/ios-icon.png">


  because idevices have different resolutions, ios also supports application icons of varying sizes

  if you create icons in different sizes, you can point to them in the html by adding a sizes parameter to the link element for each resolution you want to support


  when the user launches the game in standalone mode and later exits the game, 

  ios saves a picture of it, the next time the app is launched this image is displayed until the page
  is loaded

  all of the ios devices need an image that takes up the full screen minus the top 20 pixels that
  are reserved for the native status bar

  320X460 for the iphone and ipad

  768x1004 for the ipad



  on the ipad you can add an extra startup image for landscape mode, which would be 748x1004

  specifying a startup image

  <link rel="apple-touch-startup-image" href="images/ios-startup-748x1024.png" media="screen and (min-device-width: 768px) and (orientation: landscape)">

  if you add multiple link elements the last element simply overrides all the others unless you specify a media query to target the specific devices




all mobile devices use a standard 20px status bar at the top of the screen, even when the webapp is
running in full screen mode its visible

by adding a meta tag to the page, you can choose between a few different styles for the status bar

<meta name="apple-mobile-web-app-status-bar-style" content="black">
^toggles a solid black background on the status bar




ideally, a game running in a wep app should be no different from native form 


you want to disable overscroll

you can do this by disabling touch scroll altogether



the android browser doesnt have a feature like the meta tag that hides the safari ui

when a page loads in the android browser, it is usually displayed in such a way that the url bar
is still visible

with JS you can make the address bar disappear, or at last move it out of the way

the trick is to force the browser to scroll to the top of the page

if theres enough content, it automatically pushes the address bar out of view
because the height is set to 100%, the game only takes up as much space as it can, so scrolling to the top has no effect

you can make sure the page is long enough by increasing the height of the html element

mobile browsers have a few behaviors that are best left disabled for games


when you keep your finger pressed down for a second or two on an image a small callout appears giving you the option to follow the link, save the image, etc

the user should be able to tap and press anything without interference 

this disables the callout 

-webkit-touch-callout: none;



-webkit-user-select: none;
^disables the ability to select text and images 

the android browser also highlights clickable elements when you tap them, which you can remove with

-webkit-tap-highlight-color: rgba(0,0,0,0)

under some circumstances, the browser automatically adjusts the size of the text to account for the change in available size

you can disable automatic readjustment with

-webkit-text-size-adjust: none;





ADDING SHIT TO THE GAME BOARD
  necessary game logic
  encapsulating the state of the board in an isolated module that allows modifications to the board only when all the game rules are followed
  ensuring that the board automatically reacts to the swaps and rearranges the remaining jewels


  there are some issues that arise when the game must be able to use two different sources that control the board

  the single player experience relies on the local client side game logic

  but the game must also work with a server side implementation of the same rules


  the games mechanics are seperated from the display and input elements of the game

  the board module is a data model for the games state(gem positions)

  the only real function that it exposes is a query function for accessing the jewels on the board
  and a function for swapping jewels

  the swapping function attemts to sswap only a pair of jewels because jewels are swappable only if certain conditions are met

  swapping also has consequences, jewels are removed, new ones fall

  the board module handles all these things automatically

  at some point, you can add webworkers to move the board logic to a seperate thread by creating
  a web worker based bard module that exposes the same methods as the one created in this chapter

  web workers communicate with the rest of the application via an asynchronous messaging api, which means that all the board modules must be able to function asynchronously 

  if you wanted to have a module that validates board data with a server side backend, you need to send
  an asynchronous ajax request to the server

  every function that modifies the game state would require a trip to the server and back before the response could be given to the caller

  in other words just because the function call returns, doesnt mean the result is ready


  you can solve this problem of deferred response in several ways

    one of the ways is using full-fledged custom event dispatching, or the concept of promise objects (node.js shit)

    the simplest solution is to just provide a callback function as an argument to the relevant method, and have that method call the callback function when it is done

  when you fill the board you have to be careful to fill the board in such a way that there are no
  combinations when the board is initially created, that would result in the player getting points 
  without doing anything


after performing a swap, the game must search for chains to remove


because the swap function needs to be exposed to the rest of the board, and because it potentially modifies the board, it mush work in the same asynchronous fashion as the initialize function

besides the two sets of coords, swap takes a callback function as its 5th argument

if the swap succeeds, the callback function is called with either a list of events that happened, or false (if its invalid)


DELEGATING TASKS TO WEB WORKERS
  how to use web workers to create a worker based version of the board module 

javascript is single threaded by design, you cannot run things in parallel, anything you ask the
browser to is processed in a serial manner. when you use functions like setTimeout or setInterval what youre really doing is pushing those functions onto the same event loop that the main thread uses

one drawback to this is that you cannot have any function that blocks the execution and expect the browser to behave

xmlhhttprequest obejct has synch and non sycnh modes, if you use synch requests, you tie up the thread,
blocking any further execution until the request has finished

web workers solve this problem by introducing functionality that resembles threads

with web workers, you can load scripts and make them run in the background, independent from the main thread. a script that runs in a worker cannot affect or lock up the main thread (the browser window, which means you can do
massive cpy intensive processing

the web workers specification defines the functionality of workers as being
thread-like because implementations dont necessariyl have to use actual OS-level threads

theyre thread-like, not actual threads per say, since:
  -the implementation of workers is up to browser vendors
even though they are often mentioned in the same sentence as other html5 features, web workers
are not part of the html5 specification but have their own specification.

workers do have some limitations- 
  in most cases these contraints dont pose problems as long as your code is encapsulated well and data
  is isolated...


1. the first isse is the seperation of state and data 
    no data from the parent thread is accessible from the worker thread, or vice versa. 
    any changes to the data of either thread must happen through the messaging API
      this limitation actually helps a lot with avoiding nasty concurrency problems.
    if workers could freely manipulate the variables in the parent thread, the risk of running into
    problems such as deadlocks, and race conditions would make workers very tough

2. no dom access
    this seperation btween worker and parent thread also means that workers have no access to the DOM 
    (window and document objects dont exist in them)
    workers can however send messages to the main thread that are then used to change the dom
    the messaging api doesnt restrict you from defining your own message protocol for updating certain
    dom elements or exchanging information about the elements of the document.

      if youre going to do alot of dom manipulation, its better to reconsider if that functionality should belong to a worker

web workers are not supported in all browsers (IE is missing them, shocking)

theyre also not supported on mobile browsers

since this is the case, the best thing to do is make your use of workers optional


what can workers do?
  in general workers can do anything you would otherwise do with javascript

  creating a worker simply loads a script and executes it in a background thread

  in pure js you have access to a few extra methods

  importScripts()
    - you provide this function a list of paths that point to scripts you want to load
    - the function is variadic, which means that you must specify the paths as individual arguments

  importScripts('script1.js', 'script2.js', ....)


  all these files are loaded synchronously, so the function doesnt return until all scripts loaded

  after a script is loaded, it is executed within the same scope as the calling worker

  this means that the script can use any variables and functions declared in the worker and the worker can subsequently use any variables and functions introduced by the imported script (allows for easy seperation of worker code into discrete modules)

  the script that created the worker can terminate the worker when it is no longer needed, but the worker itself can also choose to exit

  ( a worker can kill itself by calling the close() function)


  the timer functions that you know from the window object are all available in worker threads, which means that you are free to use the following functions

    setTimeout()
    clearTimeout()
    setInterval()
    clearInterval()


you can also use the xmlhttprequest object to create and process background ajax requests

  this object is especially useful if you need a background worker that continuously pings the server for updates that are then relayed to the main thread via the api

  because blocking in a worker thread does not affect the main ui thread, you can even do synchronous requests, which is normally a bad idea in non-worker code (it freezes the browser)


  Websockets support in worker threads is a bit of a gray area.
    eg. chrome allows it, but firefox only lets you use it in the main JS thread



to create workers you use the worker constructor

  var worker = new Worker('myworker.js')


you can only create workers from scripts that have the same origin as the creating script
  that means you cant refer to the scripts on other domains 
  the script must also be loaded using the same scheme
    - (the script cant use https if the page uses http)

you also cant create workers from a script running locally

when youre done using the worker you can call:

 worker.terminate()

this kills it an frees up memory


you can create more than worker thread
you can also create more than one worker from the same script
  some tasks are well suited for this kind of parallelization, and can provide a performance boost
  unfortunately workers are not meant to be created in large numbers due to the overhead cost
  of setting them up, so keep it down to 1 or two workers



SENDING MESSAGES -
  workers and their parent communicate through a common messaging API
  data is sent back and forth through strings, but that doesnt mean you can send only one string messages


  if you send any complex structure such as an array or object, it is automatically converted to json

  this automatic conversion of json allows you to build fairly advanced messages, but not that some things (like dom elements) cant be converted to json


  in the creating thread, call the postMessage() method on the worker with the data that you want to send

  //send a string
  worker.postMessage('hello worker')
  //send an array
  worker.postMessage([0,1,2])
  send an object literal
  worker.postMessage({
    command: 'pollServer',
    timeout: 1000
  })

  in the same way, simply call postMessage() to send messages from the worker to the main thread

  postMessage('im read to work master')




RECEIVING MESSAGES

  messages can be intercepted by listening for the message event.
  in the parent thread, the event is fired on the worker object, whereas on the worker object, it is fired on the global object


  to listen for messages from a worker, attach a handler to the message event

  worker.addEventListener('message', function(event) {
    //message received from the worker thread
  }, false)


  in the worker thread you listen for message events on the global object
  addEventListener('message', function(event) {
    //message received from the main thread
  })

  in both cases, you can message data in the data property on the event object.
  its automatically encoded from json


CATCHING ERRORS
  if an error occurs in a worker thread, you might want to know about it in the main thread so that
  you can display a message, create a log entry, and so forth.

  in addition to the message event, worker objects also emit an error event, which is fired
  if an error happens that is not caught in the worker thread

  when the event fires, it is too late to do anything about the error. the worker has already stopped whatever it was doin, but at least you can be informed that the error occured

  worker.addEventListener('error', function(error) {
    alert('worker error: ' + error)
  }, false)


SHARED WORKERS
  there are two types of web workers: dedicated, and shared.

  shared workers can have multiple connections, they are not bound to one html page. 
  if you have multiple html pages from the same origin running in the same browser, these pages can 
  all access any shared workers created by one of the pages


  to create a shared worker, use the SharedWorker() constructor.
  in addition to the script path, this constructor also takes a second optional name parameter.
  if the name parameter is not given, an empty string is used for the name.
  if you attempt to create a shared worker and one has already been created with the same script and name, a new connection to that worker is created instead of a brand new worker

  shared workers dont have a global message event like dedicated workers do.
  instead they must listen for connect events that fire whenever a new page creates a connection to 
  the worker

  communication between the worker and connecting threads happens via port objects that emit message events and expose the postMessage() method

  the port.start() function must also be called before messages can be received



  look at this example:
    it will use a dedicated worker to do some intensive processing, and freeing up the main thread


    function isPrime(n){
      if (n < 2) return false;
      for (var i = 2, m=Math.sqrt(n); i <= m; i++)
        if (n % i === 0) {
          return false
        }
    }
    return true
    }


  if a pair of divisors exists, one of the divisors must be smaller than or equal to the square root
  of n, so you need to test only numbers in the range [2, sqrt(n)] to determine the primality of n

  so for each number i from 2 to sqrt(n), you use the remainder operator to test whether i can divide n
  if it can n is not prime and isPrime returns false

  if the loop exits without finding a divisor, n is prime and returns true


WHEN TO USE WEB WORKERS IN GAMES
  do you need to move the game element to a seperate worker thread?
  does the game element do anything that could run independently

  does the game element depend on having access to the dom?

  remember that worker threads cannot access the document, so anything to do with the dom must be in the main thread


  good candidates are artificial intelligence, and physics simulations

    theyre demanding on the cpu and dont need to run in the same thread as long as the data is kept synchronized

THE WORKER MODULE
  because the game module was designed with multiplayer support in mind it already has an asynchronous interface.




importing the script the regular board module allows you to reuse  funcitonality
 because the module is created in the jewel namespace, an empty jewel obect is created prior to importing the script if the object doesnt exist when the script is imported, youd get an error

when the worker receives a message from the game, it needs to call the
 appropriate method on the imported board module and post back the results
 the messages coming from the game to the worker use a custom message format described
 by this object literal:
 
 {
  id: number,
  command: string
  data: any
 }

 id identifies the mesage, the command property
 is a string that determines what the worker should do
 data is all the data the worker needs to do the command

 all messages posted to the worker trigger a response message with this format:

 {
  id: number,
  data: any,
  jewels: array
 }


 the id is the id number from the original message, 
 data is the response data, and jewels 
 contains a 2d array that represents the current state of the jewel board
 the board data is always attached so that the main thread can keep a local copy of the data for
 easy access

the worker has 2 commands, initialize and swap
theyre mapped to the corresponding methods on the board module

when the worker receives the initialize command, data must contain the settigs object from the jewel
namespace in the parent


the board initialize function takes a callback function as its first and only argument, a special
callback function is defined in the worker and is passed to board.initialize and any other asynch
board methods

when the callback is called function is called, the data parameter is sent to the main thread as a message, and its then up the main thread to handle the callback message




the worker defined the callback method, whenever anything happens that
changes the state of the board (initialize, and swap), the worker 
sends a message to the main thread 

the game should be able to run with and without worker support

  you need a new worker-based board module that has the same interface as the non-worker
  board.js module

any functions exposed in the board module must also exist in the worker board module with the same signiatures  (initialize(), swap(), getBoard() )


if they have the same signatures, you can replace one module with the other, and 
the game doesnt care

you know that only some browsers support workers, the board board module (for the workers)

must be loaded only if workers are available

if not, the game must fall back to the regular board module


when you use the worker constructor to create a new worker, the script is automatically pulled from the server

it would be nice if the file were already in the cache so the user didnt have to wait for the additional http request before the game could begin

if you simply added the script to the modernizr load call in the loader script, errors could occur because the worker script uses functions that are not available outside the worker (like importScripts() )


you could test for the presence of that function and execute the rest of code only if it exists

a more elegant method would be to just make sure the file is loaded and not executed

yepnope uses something called prefixes - 
  they enable you to define a prefix that if found in the script path, triggers extra functionality


CREATING GRAPHICS WITH CANVAS

the canvas element allows for developers to create dynamic graphics
it provides a 2 dimensional drawing surface with a JS api for drawing shapes, paths, and objects

it is so fully featured that it can create a near complete canvas based svg render

a major difference between svg and canvas is that the canvas api does something called an 
"immediate mode"
this immediate mode allows any content drawn on the canvas is immediately rasterized and rendered
to the surface

rasterize - the process of converting a vector image into a bitmap image

the canvas does not maintain any internal structure of the shapes and paths that ahve been drawn
as soon as you tell the canvas to draw, it does the job and then forgets what the pixels represent

this is different from an svg element, which has an xml structure that describes which elements make
up the image


canvas is really good when you need fine grained control over the input

with pixel level data access, you can do things that are not possible with any other technology

a disadvantage to canvas:

  even if its drawing functions are vector based, its outputs are bitmaps which are subject to scaling
  issues

  howver, because all canvas based graphics are created programatically, you have the option
  of creating them in the best resolution at runtime


  there is actually an advantage to having bitmap based ouptut

    you dont need to worry about how many times you add content to the canvas element, no matter how many
    shapes and images you add, the canvas is always just a bitmap

    you dont need to worry about filling the canvas element with too much content that could slow things
    down




you can create a canvas element the same way you can create other dom elements

  var canvas = document.createElement('canvas')
  document.body.append(canvas)


or you can just use markup

<canvas id="canvas"> </canvas>


the markup creates a canvas element withthe default dimensions of 300x150

when its created its fully transparent

you can also add feedback by adding children to it

<canvas> <h3> this requires a modern web browser </h3> </canvas>


the browser only renders whats inside the canvas element if it doesnt support canvas

theres an important concept to understand about canvas

  it does not provide any graphics functionality itself, it just defines a surface and exposes a few properties for setting dimensions


canvas.width = 400
canvas.heigh = 300

a canvas' dimensions are not necessarily equal to its CSS dimensions.

You can scale a canvas element to any width and heigh using CSS without any effect to the actual
dimensions of the canvas

the contect is simpy stretched. (like a bitmap)


when you add graphics to the surface, you have to do so using a context object created using
the getContext() method on the canvas element

var ctx = canvas.getContext('2d') //creates a 2d context object

  for the getContext() method the parameter is a context type
    these context types have different interfaces for creating graphics on the canvas
    interface

  right now, besides the 2d context, the only other context it accepts is the WebGL context


many of the canvas functions use the same path API to define paths of points that make up the shape you
want to draw

you initiate a new path by calling the ctx.beginPath() method on the context object (ctx)
  this also clears all previously added path data


there are a few different methods for adding path segments
  the most basic adds a line segment
    ctx.beginPath()
    ctx.moveTo(150,200)
    //moveTo creates a new subpath with a single point at the specified coordinates
    ctx.lineTo(250,200)
    ctx.lineTo(250,230)
    ctx.lineTo(150,230)
    //the lineTo methods moves the position, adds a new point, and connects it to the previous position with a line
    ctx.closePath()
    //closes the path, it creates a final line segment from the current position to the position
    //of the first point
    //in this case it adds the fourth edge to a rectangle
  
    //close path is optional, you may not want to always close the path

a path is made up of a number of subpaths.



if you dont call moveTo to create a subpath it is automatically created when lineTo is called. 
BUT, since there was no starting position defined, that lineTo method call only moves the posiition 
and does not start a line

you should not use the beginPath method to create additional subpaths because that function clears
all path data before creating the new path

if you want to add more subpaths to the current path, you use moveTo()

if you have a defined path, you can draw it to the canvas surface
  the canvas api has two different methods for converting the path to graphics
    1. ctx.fill() - colors the inside
    2. ctx.stroke() - colors the edges


  the color for each of these methods is given by these 2 methods
    ctx.fillStyle()
    ctx.strokeStyle()

  eg
    ctx.fillStyle = '#aaeeaa'
    ctx.strokeStyle = '#111155'

the colors have the same format of css (rgb(), hexadecimal, keywords)


you can also set the linewdith 

  ctx.lineWidth = 5.0

after youve set the path and defined fill and stroke styles, you can call either of the 2 methods
  that convert paths to graphics
    fill()
    stroke()

when you draw a strokeline around an object, the line is drawn so that the path is smack dab in the middle, which means that half the line is outside the shape, and half is inside

if either the fill or stroke color is non-opaque it is usually a good idea to draw the transparent part first to avoid unwanted bleeding near the edge

there is a small caveat with horizontal and vertical lines
  since strokes are drawn with the path in the center, a 1 pixel wide vertical line ould have half a pixel on the left, and half on the right

  you cant do that because there isnt such a thing as half a pixel. idiot. 
  what ends up happening is that a semitransparent 2 pixel wide line is used instead

  an easy fix for this is to add .5 to both the x and y coordinates of the points, making the line centered on a pixel



  it would suck if you had to go through the procedure of pathing each time you wanted to create something


  ctx.rect(x,x,x,x) 
  ^ a shortcut, cool


  ctx.beginPath()
  ctx.rect(150,200,100,30)
  ctx.fillStyle = 'rgba(sdfsdf)'
  ctx.fill()


  or you can just do 
  ctx.fillStyle = 'rgba(234234)'
  ctx.fillRect(150, 200,100,30)

  or 
  ctx.strokeStyle = 'rgba(234234)'
  ctx.strokeRect(150, 200,100,30)



  ctx.clearRect(150,200,100,30)
  ^instead of drawing, it clears the area
  all pixels in the specified rectablge are set to black with the alpha channel set to 0 (fully transparent)


  if you want to clear the entire canvas you can just set the heigh or width property on the canvas element, even setting the value to itself triggers it

  canvas.width = canvas.width


BEzier curves

ctx.quadraticCurveTo(cx,cy,x,y)

^ this method takes 2 points as paramaters,
  x,y refer to the startpoint of the cuve
  cx, cy refer to the control point of the curve

the control point essentially pulls the curve toward it

check this out dawg

ctx.beginPath()
ctx.moveTo(50,200)
ctx.quadraticCurveTo(425,25,450,200)

this curve starts at 50, 200 and ends at 450,200, and the control point is 425,25


the second curve method is called ctx.bezierCurveTo()

this method creates a cubic bezier curve
  cubic curves take two control points, 

ctx.beginPath()
ctx.moveTo(50,200)
ctx.bezierCurveTo(150,25,350,350,400,200)

with cubic curves you can easily add one after the other to form longer and more detailed curves

just put the first control point of the following curve segment in the opposite direction of the last control point of the previous segments


Clipping Paths

use ctx.clip() to clip paths
  this makes the current path act as a mask that is applied to all subsequent drawing functions

  as long as the clipping path is active, only the area within that region is modified


advanced stroke and fill styles

  you can use a few additional paramters to control the appearance of a stroke

  line caps-
    ctx.lineCap property
      there are 3 values:
        1. butt: a clean perpendicular cut at the end of the stroke, the last point in the path is positioned in the center of the line cap

        2. round: rounds the end of a stroke by drawing a semicircle with the center positioned at the
        last point

        3. square: looks like butt, only it extends so the last point is positioned in the center of a square


  line joints - p 240
    ctx.lineJoin property
      it describes what to do whenever two consecutive path segments share the same point 
        all three have the same starting condition
      3 values:
        1. bevel: this joint fills the triangle defined by the meeting point and the two outer corners

        2. round: round builds on the bevel and smoothes out the joint by rendering an arc connecting
        the outer corners

        3. miter: the default value


  gradients: 

    strokes and fills dont have to be plain or solid
      canvas supports both linear and radial gradients

    to use gradients you have to create a gradient object
      var gradient = ctx.createLinearGradient(50,50,250,400)
        this creates a linear gradient along the line from 50,50 to 250,400


    to create a radial gradient:
      var gradient = ctx.createRadialGradiant(100,100,10,100,100,175)
        this creates a radial gradient with an inner circle centered at 100,100, a radius of 10, 
        and an outer circle in the same spot but with a radius of 175


    both gradient objects expose an addColorStop() method thata you can use to assign colors to the gradient
      gradient.addColorStop(0,'red')
      gradient.addColorStop(.5, 'green')
      gradient.addColorStop(1, 'blue')

    ^this creates a gradient red at the start, the green, then blue

    to use the gradient you have to assign it to either the fillStlye or strokeStyle property

    Patterns
      you can use an existing images for patterns, it can be a canvas element, a video element, or a regular image

    var gradient = ctx.createPattern(
      document.getElementById('myImage'),
      'repeat'
    )

    the second argument specifies how the pattern should repeat,
      repeat - default (repeats in both directions)
      repeat-x - 
      repeat-y
      no-repeat

    the pattern is anchored at the origin of the coordinate space and is not affected by where you use it


    this means that a pattern created from a small image with no repetition may not be visible in the bottom right corner of the canvas


    the ctx.createPattern() method returns a pattern object that has no properties or methods
      just assign it to the strokeStyle or fillStyle


TRANSFORMATIONS
  when you create a new canvas element, the coordinate space used to draw content on it correspoonds to the dimensions of the canvas element.

  the pixel in the upper left coordinate is 0,0
  the pixel in the bottom right corner is (w - 1, h - 1)

  the transformation matrix:
    every point used by the canvas is multiplied by this matrix before it is used for rendering

    the identity matrix: 

    1 0 0
    0 1 0
    0 0 1

    if you know what the fuck youre doing with matrices, 
      you can set the transformation matrix using 
        ctx.transform(a,b,c,d,e,f)
        this method multiplies the current matrix with the matrix

      you end up with

      a c e
      b d f
      0 0 1


    you can also use the set transform method to completely overwrite the matrix
    (it essentially resets the matrix to the identity matrix and then multiplies it with your arguments
    )
       ctx = setTransform(a, b, c, d, e, f)


TRANSLATING

  the translate method object adds a translation matrix to the transformation

  ctx.translate(x,y)

  this basically adds the x and y value to the coordinate of any points you draw



SCALING 
  you can scale the cooridinate space using
  ctx.scale(2, .5)

  ^this cales the object to twice its width and half its height


you can also achieve this same effect by appling this transformation:
  ctx.transform(2,  0,
                0, .5,
                0,  0)


a neat trick to scale the coordinate space so the entire canvas surface lies within 1 unit in the
coordinate space is by scling the coordinate using the dimensions of the canvas

ctx.scale(1 / canvas.width, 1 / canvas.height)

^ after that, all coordinates are now relative to the dimensions, and all visible points
on the canvas lie between 0 and 1 on both axes. for example, drawing a rectangle that fills the upper right quarter just requires:
    ctx.fillRect(.5, 0, .5, .5)

ROTATING:

  ctx.rotate(t)

  ^this method rotates the object t radians to the left


adding text, images, and shadows

you can also add txt and images to a canvas

ctx.drawImage(image, dx, dy, dw, dh)
  ^draws an image to the canvas, the upper left corner is dx, dy
  if dw and dh are left out, they default to the images default dimensions

Text drawn on the canvas cannt be seleted with a mouse, however you can provide the text as fallback
content for the page



how do you scale the jewel sizes so that you make sure the browser gets the right sized sprite?

  you cant pass the information from css to js,
    but you can style an html element and then pick up its dimensions with js


if you can track the progress of the scripts loading, youll know when the user can move forward to
the menu

you can use a yepnope prefix to keep track of how many files have finished loading

the purpose of the prefix is to track two things,
how many files are being loaded and how many of those files have finished loading

when you add a prefix to yepnope, the associated function is called
once for each file with that prefix, this call happens before the file starts loading
the loader! prefix first uses a simple regex to determine if the resource is an image file, and if it is, stops yepnope from trying to execute it as a script


then a counter is incremented so that after the actual loading starts, numPreload equals the number
of files that will be loaded

prefix functions also allow you to attach a function to the autoCallback property of the resource object
, this function is called when the fule finishes loading.


the splash screen should show the loading progress of the game

    getLoadProgress() returns a value between 0 and 1 indicating how far loaded it is


  






























































